<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teleprompt - AI Drawing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body class="min-h-screen gradient-bg">
    <!-- Moving Emoji Mesh Canvas -->
    <canvas id="emojiMesh" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none;"></canvas>
    <div class="container mx-auto px-4 py-8" style="position:relative;z-index:1;">
        <div class="max-w-md mx-auto bg-white rounded-lg shadow-xl p-8">
            <div class="text-center mb-8">
                <h1 class="text-3xl font-bold text-gray-800 mb-2">ðŸŽ¨ Teleprompt</h1>
                <p class="text-gray-600">AI-powered drawing game with friends</p>
            </div>

            <form id="joinForm" class="space-y-4">
                <div>
                    <label for="playerName" class="block text-sm font-medium text-gray-700 mb-2">Your Name</label>
                    <input type="text" id="playerName" name="playerName" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                           placeholder="Enter your name" required>
                </div>

                <div>
                    <label for="roomCode" class="block text-sm font-medium text-gray-700 mb-2">Room Code</label>
                    <input type="text" id="roomCode" name="roomCode" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                           placeholder="Enter room code" required>
                </div>

                <button type="submit" 
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                    Join Game
                </button>
            </form>

            <div class="mt-6 text-center">
                <button id="createRoomBtn" 
                        class="text-blue-600 hover:text-blue-800 font-medium">
                    Create New Room
                </button>
            </div>

            <div id="status" class="mt-4 text-center text-sm text-gray-600 hidden"></div>
        </div>

            <div id="gameInfo" class="max-w-md mx-auto mt-4 bg-white rounded-lg shadow-lg p-6 hidden">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">Players in Room</h3>
                <div id="playersList" class="space-y-2"></div>
                <div id="gameStatus" class="mt-4 text-center text-sm text-gray-600"></div>
                <div id="startGameSection" class="mt-4 hidden">
                    <button id="startGameBtn" 
                            class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Start Game with Random Image
                    </button>
                    <p class="text-xs text-gray-500 text-center mt-2">Room creator can start with any number of players</p>
                </div>
            </div>
    </div>

    <script>
        // Clear cache and cookies on page load
        if ('caches' in window) {
            caches.keys().then(function(names) {
                for (let name of names) {
                    caches.delete(name);
                }
            });
        }
        
        // Clear localStorage and sessionStorage
        localStorage.clear();
        sessionStorage.clear();
        
        // Clear cookies
        document.cookie.split(";").forEach(function(c) { 
            document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
        });
        
        console.log('ðŸ§¹ Cache, cookies, and storage cleared on page load');
        
        const socket = io();
        let currentRoom = null;
        let playerName = null;
        let isRoomCreator = false;

        // Generate random room code
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // Join room
        function joinRoom(name, room) {
            playerName = name;
            currentRoom = room;
            socket.emit('join_room', {
                player_name: name,
                room_code: room,
                is_creator: isRoomCreator
            });
        }

        // Form submission
        document.getElementById('joinForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const name = document.getElementById('playerName').value.trim();
            const room = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (name && room) {
                isRoomCreator = false; // Reset creator status when joining existing room
                joinRoom(name, room);
            }
        });

        // Create new room
        document.getElementById('createRoomBtn').addEventListener('click', function() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                alert('Please enter your name first');
                return;
            }
            
            const newRoom = generateRoomCode();
            document.getElementById('roomCode').value = newRoom;
            isRoomCreator = true; // Mark as room creator
            joinRoom(name, newRoom);
        });

        // Start game button
        document.getElementById('startGameBtn').addEventListener('click', function() {
            if (isRoomCreator && currentRoom) {
                socket.emit('start_game_manual', {
                    room_code: currentRoom,
                    player_name: playerName
                });
            }
        });

        // Socket event listeners
        socket.on('player_joined', function(data) {
            document.getElementById('status').textContent = `Joined room as ${data.player_name}`;
            document.getElementById('status').classList.remove('hidden');
            
            // Update room creator status
            if (data.is_creator !== undefined) {
                isRoomCreator = data.is_creator;
            }
            
            updatePlayersList(data.players);
            updateGameStatus(data.ready_to_start);
        });

        socket.on('player_list_updated', function(data) {
            updatePlayersList(data.players);
            updateGameStatus(data.ready_to_start);
        });

        socket.on('player_left', function(data) {
            updatePlayersList(data.players);
            updateGameStatus(data.ready_to_start);
        });

        socket.on('room_full', function(data) {
            alert(data.message);
        });

        socket.on('game_started', function(data) {
            window.location.href = `/game/${currentRoom}?player=${encodeURIComponent(playerName)}`;
        });

        socket.on('error', function(data) {
            alert(data.message);
        });

        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'flex items-center space-x-2 p-2 bg-gray-50 rounded-md';
                playerDiv.innerHTML = `
                    <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                    <span class="text-gray-700">${player}</span>
                `;
                playersList.appendChild(playerDiv);
            });
            
            document.getElementById('gameInfo').classList.remove('hidden');
        }

        function updateGameStatus(readyToStart) {
            const statusDiv = document.getElementById('gameStatus');
            const startGameSection = document.getElementById('startGameSection');
            const playerCount = document.getElementById('playersList').children.length;
            
            // Game no longer auto-starts, so always show manual start option
            statusDiv.textContent = `Players in room: ${playerCount}`;
            statusDiv.className = 'mt-4 text-center text-sm text-gray-600';
            
            // Show start button for room creator if there are at least 2 players
            if (isRoomCreator && playerCount >= 2) {
                startGameSection.classList.remove('hidden');
            } else {
                startGameSection.classList.add('hidden');
            }
        }

        // Emoji Mesh Physics Simulation
        const canvas = document.getElementById('emojiMesh');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        const phoneEmoji = 'ðŸ“ž';
        const brainEmoji = 'ðŸ§ ';
        const gridCols = Math.floor(width / 70);
        const gridRows = Math.floor(height / 70)+1;
        const spacing = 70;
        const mesh = [];
        const springs = [];
        let mouse = {x: -1000, y: -1000};
        // Node structure: {x, y, vx, vy, baseX, baseY, emoji}
        for (let r = 0; r < gridRows; r++) {
            for (let c = 0; c < gridCols; c++) {
                mesh.push({
                    x: c * spacing + spacing/2,
                    y: r * spacing + spacing/2,
                    vx: 0,
                    vy: 0,
                    baseX: c * spacing + spacing/2,
                    baseY: r * spacing + spacing/2,
                    emoji: (r + c) % 2 === 0 ? phoneEmoji : brainEmoji
                });
            }
        }
        // Connect springs (adjacent nodes)
        function nodeIdx(r, c) { return r * gridCols + c; }
        for (let r = 0; r < gridRows; r++) {
            for (let c = 0; c < gridCols; c++) {
                let idx = nodeIdx(r, c);
                if (c < gridCols - 1) springs.push([idx, nodeIdx(r, c+1)]);
                if (r < gridRows - 1) springs.push([idx, nodeIdx(r+1, c)]);
            }
        }
        // Mouse interaction
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mouseleave', () => {
            mouse.x = -1000; mouse.y = -1000;
        });
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });
        function stepPhysics() {
            // Spring forces
            for (const [i, j] of springs) {
                const a = mesh[i], b = mesh[j];
                const dx = b.x - a.x, dy = b.y - a.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const rest = spacing;
                const force = 0.02 * (dist - rest); // reduced spring force for slower movement
                const fx = force * dx / (dist || 1);
                const fy = force * dy / (dist || 1);
                a.vx += fx; a.vy += fy;
                b.vx -= fx; b.vy -= fy;
            }
            // Jiggle/ripple
            for (const node of mesh) {
                // Restore to base position
                const dx = node.baseX - node.x;
                const dy = node.baseY - node.y;
                node.vx += 0.004 * dx + (Math.random()-0.5)*0.02; // slower restoration and less random jiggle
                node.vy += 0.004 * dy + (Math.random()-0.5)*0.02;
                // Mouse repulsion
                const mx = node.x - mouse.x;
                const my = node.y - mouse.y;
                const mdist = Math.sqrt(mx*mx + my*my);
                if (mdist < 120) {
                    const repulse = 2 * (1 - mdist/120);
                    node.vx += repulse * mx/(mdist||1);
                    node.vy += repulse * my/(mdist||1);
                }
                // Damping
                node.vx *= 0.75;
                node.vy *= 0.75;
                node.x += node.vx;
                node.y += node.vy;
            }
        }
        function drawMesh() {
            ctx.clearRect(0, 0, width, height);
            ctx.font = '40px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.save();
            ctx.globalAlpha = 0.5; // half transparency for all emojis
            for (const node of mesh) {
                ctx.fillText(node.emoji, node.x, node.y);
            }
            ctx.restore();
        }
        function animate() {
            stepPhysics();
            drawMesh();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>


